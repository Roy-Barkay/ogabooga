"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _TextField = _interopRequireDefault(require("@material-ui/core/TextField"));
var _inputMask = _interopRequireDefault(require("../../utils/inputMask"));
var _utils = require("../../utils");
var _formik = require("formik");
var _styles = require("@material-ui/core/styles");
var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));
require("./TextField.css");
var _excluded = ["inputRef", "maskPlaceHolder", "maxLength", "minLength"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var TextMaskCustom = function TextMaskCustom(props) {
  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  var inputRef = props.inputRef,
    maskPlaceHolder = props.maskPlaceHolder,
    maxLength = props.maxLength,
    minLength = props.minLength,
    other = (0, _objectWithoutProperties2.default)(props, _excluded);
  function beforeMaskedStateChange(_ref) {
    var nextState = _ref.nextState;
    var value = nextState.value;
    value = value.toString();
    if (value && value.endsWith('/')) {
      value = value.slice(0, -1);
    }
    return _objectSpread(_objectSpread({}, nextState), {}, {
      value: value
    });
  }
  return /*#__PURE__*/_react.default.createElement(_inputMask.default, (0, _extends2.default)({}, other, {
    ref: inputRef,
    mask: props.mask,
    beforeMaskedStateChange: beforeMaskedStateChange,
    maskPlaceholder: null
  }));
};
TextMaskCustom.propTypes = {
  mask: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.string]),
  inputRef: _propTypes.default.func,
  maskPlaceHolder: _propTypes.default.string,
  minLength: _propTypes.default.number,
  maxLength: _propTypes.default.number
};
var styles = function styles(theme) {
  return {
    root: {
      '& input:-webkit-autofill, & input:-webkit-autofill:focus, & input:-webkit-autofill:hover, & input:-webkit-autofill:active': {
        '-webkit-box-shadow': 'none!important',
        '-webkit-text-fill-color': theme.palette.primary.main
      }
    }
  };
};
function TextField(props) {
  var pickedProps = (0, _utils.pick)(['error', 'label', 'onFocus', 'onBlur', 'multiline', 'fullwidth', 'autoComplete', 'autoFocus', 'defaultValue', 'disabled', 'helperText', 'FormHelperTextProps', 'id', 'margin', 'classes', 'name', 'onChange', 'onClick', 'placeholder', 'InputProps', 'inputProps', 'InputLabelProps', 'inputRef', 'required', 'rows', 'rowsMax', 'type', 'value', 'mask', 'maxLength', 'variant', 'multilinelabel', 'arialabelledby'], props);
  var dataHrlBo = props['data-hrl-bo'];
  var customAriaLabelledBy = !!props.arialabelledby ? " ".concat(props.arialabelledby) : '';
  pickedProps.inputProps = Object.assign({}, pickedProps.inputProps, dataHrlBo && {
    'data-hrl-bo': "".concat(dataHrlBo, "_input")
  }, props.directionLtr && {
    style: {
      direction: 'ltr',
      textAlign: 'left'
    }
  }, props.maxLength && {
    maxLength: props.maxLength
  }, props.minLength && {
    minLength: props.minLength
  }, props.mask && {
    mask: props.mask
  }, pickedProps.label && {
    'aria-labelledby': "".concat(pickedProps.id, "-label").concat(customAriaLabelledBy)
  });

  // attributes to be set on the <input>
  pickedProps.InputProps = Object.assign({}, pickedProps.InputProps, props.mask ? {
    inputComponent: TextMaskCustom
  } : {});
  pickedProps.InputLabelProps = pickedProps.InputLabelProps || Object.assign({}, dataHrlBo && {
    'data-hrl-bo': props['data-hrl-bo'] + '_label'
  }, props.value && {
    shrink: true
  }, props.required && props.hideRequiredAsterisk && {
    required: false
  });
  pickedProps.FormHelperTextProps = dataHrlBo ? {
    'data-hrl-bo': props['data-hrl-bo'] + '_helper-text'
  } : null;
  pickedProps.maxLength = props['maxLength'] ? props['maxLength'] : null;
  if (props.required) {
    // eslint-disable-next-line sonarjs/no-duplicate-string
    pickedProps.inputProps['aria-required'] = true;
  }
  if (props.invisibleRequired) {
    pickedProps.InputProps['aria-required'] = true;
  }
  if (props.readonly) {
    pickedProps.inputProps['aria-readonly'] = true;
    pickedProps.inputProps['readOnly'] = true;
  }
  if (props.ariaLabel) {
    pickedProps.inputProps['aria-label'] = props.ariaLabel;
  }
  if (props.disabled) {
    pickedProps.inputProps['aria-disabled'] = true;
  }
  var hasError = pickedProps.error;
  var fieldHelperText = pickedProps.helperText;
  if (props.form) {
    var fieldName = props.field.name;
    var touched = (0, _formik.getIn)(props.form.touched, fieldName);
    var fieldError = (0, _formik.getIn)(props.form.errors, fieldName);
    hasError = touched && fieldError;
    fieldHelperText = hasError ? fieldError : pickedProps.helperText;
  }
  var handleChange = function handleChange(e) {
    if (props.onChange && props.debounce) {
      (0, _utils.debounce)(props.onChange, props.debounceMs)(e);
    }
    if (props.onChange && !props.debounce) {
      props.onChange(e);
    }
    if (props.form) {
      var clonedEvent = Object.assign({}, e);
      clonedEvent.target.name = props.field.name;
      props.field.onChange(clonedEvent);
    }
  };
  var handleBlur = function handleBlur(e) {
    if (props.onBlur) props.onBlur(e);
    if (props.form) {
      var clonedEvent = Object.assign({}, e);
      clonedEvent.target.name = props.field.name;
      props.field.onBlur(clonedEvent);
    }
  };
  var multiLineLabelOBJ = {
    style: {
      position: 'static',
      textOverflow: 'unset',
      whiteSpace: 'unset',
      height: 'auto',
      transform: 'translate(10px, 10px)',
      width: '100%',
      padding: '0 16px 0 0',
      fontWeight: '500'
    }
  };
  var MultiLineLabelProps = pickedProps.multilinelabel ? multiLineLabelOBJ : null;
  pickedProps.InputLabelProps = Object.assign(pickedProps.InputLabelProps, MultiLineLabelProps);
  var MultiLineLabelMainDiv = {
    backgroundColor: '#e2ecf9',
    borderRadius: '4px 4px 0 0'
  };
  var multiLineLabelMainStyleChange = pickedProps.multilinelabel ? MultiLineLabelMainDiv : null;
  return /*#__PURE__*/_react.default.createElement(_TextField.default, (0, _extends2.default)({
    autoComplete: "off"
  }, pickedProps, {
    inputRef: pickedProps.inputRef,
    onChange: handleChange,
    onBlur: handleBlur,
    helperText: fieldHelperText,
    error: !pickedProps.disabled && hasError,
    "data-hrl-bo": "bo-textField-".concat(dataHrlBo),
    style: multiLineLabelMainStyleChange
  }));
}
TextField.propTypes = {
  /** If true, the input element will be focused during the first mount. */
  autoFocus: _propTypes.default.bool,
  /** Override or extend the styles applied to the component. See CSS API below for more details. */
  classes: _propTypes.default.object,
  /** The default value of the input element. */
  defaultValue: _propTypes.default.any,
  /** If true, the input element will be disabled. */
  disabled: _propTypes.default.bool,
  /** If true, the label will be displayed in an error state. */
  error: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.bool]),
  /** Props applied to the FormHelperText element. */
  FormHelperTextProps: _propTypes.default.object,
  /** If true, the input will take up the full width of its container. */
  fullWidth: _propTypes.default.bool,
  /**    The helper text content. */
  helperText: _propTypes.default.node,
  /** The id of the input element. Use this prop to make label and helperText accessible for screen readers. */
  id: _propTypes.default.string.isRequired,
  /** Props applied to the InputLabel element. */
  InputLabelProps: _propTypes.default.object,
  /**    Props applied to the Input element. It will be a FilledInput, OutlinedInput or Input component depending on the variant prop value. */
  InputProps: _propTypes.default.object,
  /** Pass a ref to the input element. */
  inputRef: _propTypes.default.func,
  /* To change the direction. Default: false (rtl)  */
  directionLtr: _propTypes.default.bool,
  /**The label content. */
  label: _propTypes.default.node,
  /** If dense or normal, will adjust vertical spacing of this and contained components. */
  margin: _propTypes.default.oneOf(['none', 'dense', 'normal']),
  /**    If true, a textarea element will be rendered instead of an input. */
  multiline: _propTypes.default.bool,
  /** Name attribute of the input element. */
  name: _propTypes.default.string,
  /** Callback fired when the value is changed. */
  onChange: _propTypes.default.func,
  /** Function to be called when input was blur */
  onBlur: _propTypes.default.func,
  /**    The short hint displayed in the input before the user enters a value. */
  placeholder: _propTypes.default.string,
  /** If true, the label is displayed as required and the input element` will be required. */
  required: _propTypes.default.bool,
  /** If true, the input element` will not be required, but will have aria-required attribute.  */
  invisibleRequired: _propTypes.default.bool,
  /**    Number of rows to display when multiline option is set to true. */
  rows: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  /** Maximum number of rows to display when multiline option is set to true. */
  rowMax: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
  /** Render a Select element while passing the Input element to Select as input parameter. If this option is set you must pass the options of the select as children. */
  select: _propTypes.default.bool,
  /** Props applied to the Select element. */
  SelectProps: _propTypes.default.object,
  /**    Type of the input element. It should be a valid HTML5 input type. */
  type: _propTypes.default.string,
  /** The value of the input element, required for a controlled component. */
  value: _propTypes.default.any,
  /** The variant to use. */
  variant: _propTypes.default.oneOf(['standard', 'outlined', 'filled']),
  /**
   * mask is an array or a function that defines how the user input is going to be masked.
   * https://github.com/text-mask/text-mask/blob/master/componentDocumentation.md#mask
   */
  mask: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.string]),
  /**
   * The helper props for QA
   */
  'data-hrl-bo': _propTypes.default.string,
  /**
   * Enable debounce for onChange.
   */
  debounce: _propTypes.default.bool,
  /**
   * ms debounce. Default 1000ms
   */
  debounceMs: _propTypes.default.number,
  /**
   * Placeholder to cover unfilled parts of the mask
   */
  maskPlaceholder: _propTypes.default.string,
  minLength: _propTypes.default.number,
  maxLength: _propTypes.default.number,
  /**
   * Formik instance
   */
  form: _propTypes.default.any,
  field: _propTypes.default.any,
  /** If true, the label will not display the asterisk.  */
  hideRequiredAsterisk: _propTypes.default.bool,
  /** If true, then it will be READONLY  */
  readonly: _propTypes.default.bool,
  /** If is not empty, then it will be show in DOM  */
  ariaLabel: _propTypes.default.string,
  /** show label in multi line */
  multilinelabel: _propTypes.default.bool,
  /** Add custome aria-labelledby */
  arialabelledby: _propTypes.default.string
};
TextField.defaultProps = {
  id: "input".concat(Math.floor(Math.random() * 10000)),
  required: false,
  select: false,
  directionLtr: false,
  inputRef: null,
  type: 'text',
  debounceMs: 1000,
  maskPlaceholder: null,
  disabled: false,
  hideRequiredAsterisk: false,
  readonly: false,
  multilinelabel: false
};
var _default = (0, _styles.withStyles)(styles)(TextField);
exports.default = _default;