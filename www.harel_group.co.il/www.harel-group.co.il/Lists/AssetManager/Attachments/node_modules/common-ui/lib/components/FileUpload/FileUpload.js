"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _DragAndDrop = _interopRequireDefault(require("./dragAndDrop/DragAndDrop"));
var _constants = require("./constants/constants");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _FileSpecificationPropTypes = require("./fileSpecification/FileSpecificationPropTypes");
var _FileList = _interopRequireDefault(require("./fileList/FileList"));
var _fileUploadRequest = require("./dataFetching/fileUploadRequest");
var _lodash = require("lodash");
var _core = require("@material-ui/core");
var _formik = require("formik");
var _misc = require("../../utils/misc");
var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));
var _grey = _interopRequireDefault(require("@material-ui/core/colors/grey"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var useMocks = process.env.IS_MOCKED || false;
var FileUpload = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(FileUpload, _Component);
  var _super = _createSuper(FileUpload);
  function FileUpload(props) {
    var _this;
    (0, _classCallCheck2.default)(this, FileUpload);
    _this = _super.call(this, props);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "generateBlob", function (originalFile) {
      return originalFile.slice(0, originalFile.size, originalFile.type);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleUpload", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(files) {
        var asyncValidatorResult, i, rawFile, fileCopyAsBlob, data, response, _this$props$onError, _this$props, name, event, _this$props$onError2, _this$props2;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_this.asyncValidator) {
                  _context.next = 6;
                  break;
                }
                _context.next = 3;
                return _this.asyncValidator(files);
              case 3:
                asyncValidatorResult = _context.sent;
                if (!(asyncValidatorResult === false)) {
                  _context.next = 6;
                  break;
                }
                return _context.abrupt("return");
              case 6:
                i = 0;
              case 7:
                if (!(i < files.length)) {
                  _context.next = 23;
                  break;
                }
                rawFile = _this.addFile(files[i]);
                fileCopyAsBlob = _this.generateBlob(files[i]);
                if (rawFile.hasError) {
                  _context.next = 19;
                  break;
                }
                data = new FormData();
                data.append('data', fileCopyAsBlob, rawFile.name);
                _context.next = 15;
                return (0, _fileUploadRequest.fileUploadHttpRequest)(useMocks, _this.props.url, data, _this.updateFileProgress, rawFile, _this.props.dontUseAccessToken, _this.props.customRequestHeaders);
              case 15:
                response = _context.sent;
                if (response && response.data && response.data.success && (response.status === 200 || response.status === 202)) {
                  _this.updateFileProgress(rawFile, 100, true); //Only when file uploaded completely and got a good response give it a 100% upload rate.
                  if (useMocks) {
                    _this.uploadedFiles.push(response);
                  } else {
                    _this.arrangeResponse(response, rawFile);
                  }
                  _this.incrementFileCounter();
                  if (_this.props.getFiles) {
                    _this.props.getFiles(_this.uploadedFiles);
                  }
                } else {
                  _this.handleError(rawFile);
                  /* eslint-disable react/prop-types */
                  if (_this.props.form) {
                    name = _this.props.field.name;
                    event = (0, _misc.getEventData)(name, rawFile);
                    _this.props.field.onChange(event);
                  }
                  /* eslint-enable react/prop-types */
                  (_this$props$onError = (_this$props = _this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props, {
                    error: 'ServerSideUploadError',
                    file: rawFile
                  });
                }
                _context.next = 20;
                break;
              case 19:
                (_this$props$onError2 = (_this$props2 = _this.props).onError) === null || _this$props$onError2 === void 0 ? void 0 : _this$props$onError2.call(_this$props2, {
                  error: 'ClientSideValidationError',
                  file: rawFile
                });
              case 20:
                i++;
                _context.next = 7;
                break;
              case 23:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateFileProgress", function (rawFile, progress, isCompleted) {
      var files = _this.state.files;
      var currentFileIndex = files.findIndex(function (file) {
        return file.id === rawFile.id;
      });
      if (currentFileIndex !== -1) {
        if (progress === 100 && isCompleted) {
          rawFile.progress = progress;
        } else {
          if (progress < 100) {
            rawFile.progress = progress;
          }
        }
        files[currentFileIndex] = rawFile;
        _this.setState({
          files: files
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "generateUniqueKey", function (rawFileTypes) {
      var rawFileTypesCopy = (0, _toConsumableArray2.default)(rawFileTypes);
      return rawFileTypesCopy.map(function (fileType, index) {
        if (!fileType.uniqueKey) {
          fileType.uniqueKey = "".concat(fileType.fileTypeCode).concat(index);
        }
        return fileType;
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "arrangeResponse", function (response, rawFile) {
      var responseCopy = _objectSpread({}, response);
      var items = responseCopy && responseCopy.data && responseCopy.data.items && responseCopy.data.items.length > 0 ? responseCopy.data.items[0] : {};
      responseCopy.data.items = _objectSpread(_objectSpread({}, items), rawFile);
      var arrangedObj = {
        fileData: responseCopy.data,
        statusCode: responseCopy.status
      };
      _this.uploadedFiles.push(arrangedObj);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "addFile", function (file) {
      var fileItem = _this.generateFileItem(file);
      _this.setState(function (prevState) {
        return {
          files: prevState.files.concat(fileItem)
        };
      });
      return fileItem;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "deleteFile", function (index, fileId) {
      var _this$state$files$ind = _this.state.files[index],
        hasError = _this$state$files$ind.hasError,
        progress = _this$state$files$ind.progress;
      _this.decrementFileCounter(hasError, progress);
      var files = _this.state.files;
      var currentFileIndex = files.findIndex(function (file) {
        return file.id === fileId;
      });
      files[currentFileIndex] = {};
      _this.setState(function (prevState) {
        return {
          files: files
        };
      });
      var uploadedFilesCurrentIndex = _this.uploadedFiles.findIndex(function (file) {
        if (file && file.fileData && file.fileData.items) {
          return file.fileData.items.id === fileId;
        }
      });
      if (uploadedFilesCurrentIndex !== -1) {
        _this.uploadedFiles.splice(uploadedFilesCurrentIndex, 1);
        if (_this.props.getFiles) {
          _this.props.getFiles(_this.uploadedFiles);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateFile", function (fileId) {
      var files = _this.state.files;
      var currentFileIndex = files.findIndex(function (file) {
        return file.id === fileId;
      });
      files[currentFileIndex].uiProgress = 100;
      _this.setState({
        files: files
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incrementFileCounter", function () {
      _this.filesCounter++;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "decrementFileCounter", function (hasError, progress) {
      if (!hasError || progress === 100) {
        _this.filesCounter--;
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "addTagsToFile", function (tags, fileId) {
      var files = _this.state.files;
      var currentFile = files.find(function (file) {
        return file.id === fileId;
      });
      var currentIndex = files.findIndex(function (file) {
        return file.id === fileId;
      });
      currentFile.tags = tags;
      currentFile = _this.resetNoTagError(currentFile);
      files[currentIndex] = currentFile;
      _this.setState({
        files: files
      });
      _this.updateTagsOnUploadedFiles(tags, fileId);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "resetNoTagError", function (currentFile) {
      currentFile.errorMessage = '';
      currentFile.noTagsError = false;
      currentFile.hasError = false;
      return currentFile;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateTagsOnUploadedFiles", function (tags, fileId) {
      var uploadedFile = _this.uploadedFiles.find(function (file) {
        return file && file.fileData && file.fileData.items ? file.fileData.items.id === fileId : false;
      });
      var currentIndex = _this.uploadedFiles.findIndex(function (file) {
        return file && file.fileData && file.fileData.items ? file.fileData.items.id === fileId : false;
      });
      if (uploadedFile && uploadedFile.fileData && uploadedFile.fileData.items) {
        uploadedFile.fileData.items.tags = tags;
        _this.uploadedFiles[currentIndex] = uploadedFile;
        if (_this.props.getFiles) {
          _this.props.getFiles(_this.uploadedFiles);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "generateFileItem", function (file) {
      var name = file.name;
      var size = file.size;
      var isEncrypted = file.isEncrypted;
      var extension = file.name.split('.').pop().toLowerCase();
      return {
        name: _this.fixFileName(_this.stripExtension(name), extension),
        size: size,
        extension: extension,
        id: _this.filesIdIncrementer++,
        hasError: _this.validateFile(extension, size),
        error: _this.getFileValidation(extension, size),
        progress: 0,
        errorMessage: _this.currentFileErrorMessage,
        tags: _this.isOnlyOneFileType ? _this.fileTypes[0] : [],
        isEncrypted: isEncrypted
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "stripExtension", function (name) {
      if (name && name.split('.').length > 1) {
        var splitName = name.split('.');
        splitName.pop();
        return splitName.join('.').toLowerCase();
      }
      return name;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "removeEmptyObjectsFromFileArray", function (fileArray) {
      return fileArray.filter(function (file) {
        return !(Object.keys(file).length === 0 && file.constructor === Object);
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isThereOnlyOneFileType", function () {
      return _this.fileTypes && _this.fileTypes.length === 1;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateOneFileTypeCase", function () {
      var uploadedFiles = _this.state.files;
      var onlyFileType = _this.fileTypes[0];
      var cleanUploadedFiles = _this.removeEmptyObjectsFromFileArray(uploadedFiles);
      var successfullyUploadedFilesCount = _this.countSuccessfullyUploadedFiles(cleanUploadedFiles);
      if (successfullyUploadedFilesCount === 1) {
        return _this.generateResponse(true, _constants.VALID_MESSAGE);
      } else if (successfullyUploadedFilesCount > 1) {
        if (onlyFileType.isUniqueTag) {
          return _this.generateResponse(false, _constants.ONLY_ONE_FILE_FOR_UNIQUE_TAG_MESSAGE);
        } else {
          return _this.generateResponse(true, _constants.VALID_MESSAGE);
        }
      } else {
        if (onlyFileType.isMandatory) {
          return _this.generateResponse(false, _constants.MANDATORY_FILES_ARE_MISSING_MESSAGE);
        } else {
          return _this.generateResponse(true, _constants.VALID_MESSAGE);
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "countSuccessfullyUploadedFiles", function (uploadedFiles) {
      if (uploadedFiles && uploadedFiles.length > 0) {
        return uploadedFiles.reduce(function (acc, curr) {
          return !(0, _lodash.isEmpty)(curr) && !curr.hasError && curr.progress === 100 ? acc + 1 : acc;
        }, 0);
      }
      return 0;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validate", function () {
      var files = _this.state.files;
      if (_this.isThereOnlyOneFileType()) {
        return _this.validateOneFileTypeCase();
      }
      var mandatoryFileTypes = _this.props.hiddenFileType ? false : _this.fileTypes.filter(function (type) {
        return type.isMandatory === true;
      });
      var areMandatoryFilesDefined = _this.props.hiddenFileType ? false : _this.fileTypes.some(function (file) {
        return file.isMandatory === true;
      });
      var _this$validateAllFile = _this.validateAllFilesTagged(),
        areAllFilesTagged = _this$validateAllFile.isValid,
        tagValidatedFiles = _this$validateAllFile.files;
      var noFilesCurrentlyUploading = _this.validateNoFilesInProgress(tagValidatedFiles);
      if (!noFilesCurrentlyUploading) {
        return _this.generateResponse(false, _constants.MANDATORY_FILES_ARE_MISSING_MESSAGE);
      }
      if (areAllFilesTagged) {
        if (areMandatoryFilesDefined) {
          return _this.validateAllMandatoryTagsWereChosen(mandatoryFileTypes, files);
        }
        return _this.generateResponse(true, _constants.VALID_MESSAGE);
      }
      return _this.generateResponse(false, _constants.CHOOSE_ATLEAST_ONE_FILE_TYPE_MESSAGE);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateAllMandatoryTagsWereChosen", function (mandatoryFileTypes, files) {
      var _iterator = _createForOfIteratorHelper(files),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var file = _step.value;
          var tags = file.tags;
          if (tags && tags.length > 0) {
            var _iterator2 = _createForOfIteratorHelper(tags),
              _step2;
            try {
              var _loop = function _loop() {
                var tag = _step2.value;
                if (tag && tag.isMandatory) {
                  var mandatoryTypeIndex = mandatoryFileTypes.findIndex(function (fileType) {
                    return fileType.uniqueKey === tag.uniqueKey;
                  });
                  if (mandatoryTypeIndex >= 0) {
                    mandatoryFileTypes.splice(mandatoryTypeIndex, 1);
                  }
                }
              };
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return mandatoryFileTypes.length === 0 && _this.uploadedFiles.length > 0 ? _this.generateResponse(true, _constants.VALID_MESSAGE) : _this.generateResponse(false, _constants.MANDATORY_FILES_ARE_MISSING_MESSAGE);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateAllFilesTagged", function () {
      var files = _this.state.files;
      var cleanUploadedFiles = _this.removeEmptyObjectsFromFileArray(files);
      var isValid = true;
      for (var i = 0; i < cleanUploadedFiles.length; i++) {
        var file = cleanUploadedFiles[i];
        if (!file.hasError && file.progress === 100 && file.uiProgress === 100) {
          if (!_this.props.hiddenFileType && file && (file.tags && file.tags.length === 0 || file.tags === null)) {
            file.errorMessage = 'יש לתייג את סוג המסמך שהועלה';
            file.noTagsError = true;
            file.hasError = true;
            cleanUploadedFiles[i] = file;
            isValid = false;
          }
        } else {
          isValid = false;
        }
      }
      _this.setState({
        files: cleanUploadedFiles
      });
      return {
        isValid: isValid,
        files: cleanUploadedFiles
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateNoFilesInProgress", function (files) {
      return files.every(function (file) {
        if (!(0, _lodash.isEmpty)(file)) {
          if (file.hasError) {
            return true;
          }
          if (file.progress !== 100 && file.uiProgress !== 100) {
            return false;
          }
          if (!file.noTagsError && file.progress === 100 && file.uiProgress === 100 && file.tags && file.tags.length > 0) {
            return true;
          }
          return false;
        }
        return true;
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "generateResponse", function (isValid, returnMessage) {
      return {
        uploadedFiles: _this.uploadedFiles,
        isValid: isValid,
        returnMessage: returnMessage
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getFileValidation", function (ext, size) {
      var extError = _this.validateExtension(ext) ? null : 'ext';
      var sizeError = _this.validateSize(size) ? null : 'size';
      var emptyFileError = size !== 0 ? null : 'emptyFile';
      var maxAmountError = _this.validateMaxAmountOfFiles() ? null : 'maxAmount';
      var validationError = extError || sizeError || emptyFileError || maxAmountError;
      return {
        isValid: !validationError,
        validationError: validationError
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateFile", function (ext, size) {
      var _this$getFileValidati = _this.getFileValidation(ext, size),
        validationError = _this$getFileValidati.validationError,
        isValid = _this$getFileValidati.isValid;
      var messages = {
        ext: "\u05DC\u05D0 \u05E0\u05D9\u05EA\u05DF \u05DC\u05E2\u05DC\u05D5\u05EA \u05E7\u05D5\u05D1\u05E5 \u05DE\u05E1\u05D9\u05D5\u05DE\u05EA ".concat(ext),
        size: "\u05DC\u05D0 \u05E0\u05D9\u05EA\u05DF \u05DC\u05E2\u05DC\u05D5\u05EA \u05E7\u05D5\u05D1\u05E5 \u05D4\u05E2\u05D5\u05DC\u05D4 \u05E2\u05DC ".concat(_this.props.maxFileSize, " \u05DE\u05D2\u05D4 \u05D1\u05D9\u05D9\u05D8 "),
        emptyFile: "\u05DC\u05D0 \u05E0\u05D9\u05EA\u05DF \u05DC\u05E2\u05DC\u05D5\u05EA \u05E7\u05D5\u05D1\u05E5 \u05D1\u05D2\u05D5\u05D3\u05DC 0",
        maxAmount: "\u05E0\u05D9\u05EA\u05DF \u05DC\u05E2\u05DC\u05D5\u05EA \u05E2\u05D3 ".concat(_this.props.maxAmountOfFiles, " \u05E7\u05D1\u05E6\u05D9\u05DD ")
      };
      _this.currentFileErrorMessage = messages[validationError] || '';
      return !isValid;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateExtension", function (fileExtension) {
      var isValid = false;
      _this.allowedExtensions.forEach(function (extension) {
        if (extension === fileExtension) {
          isValid = true;
        }
      });
      return isValid;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateSize", function (fileSize) {
      var fileSizeMb = _this.convertToMb(fileSize);
      return _this.props.maxFileSize > fileSizeMb;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "validateMaxAmountOfFiles", function () {
      var maxAmountOfFiles = _this.props.maxAmountOfFiles ? _this.props.maxAmountOfFiles : _constants.DEFAULT_MAX_FILES;
      return maxAmountOfFiles > _this.filesCounter;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "convertToMb", function (bytes) {
      return bytes / 1024 / 1024;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getAllowedExtensions", function () {
      return Array.isArray(_this.props.allowedExtensions) ? (0, _toConsumableArray2.default)(_this.props.allowedExtensions) : _constants.DEFAULT_EXTENSIONS;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "fixFileName", function (name, extension) {
      var concatenatedName = "".concat(name, ".").concat(extension);
      var manipulatedName = _this.cleanWhitelistChars(concatenatedName);
      if (concatenatedName && concatenatedName.length > 50) {
        manipulatedName = name && extension ? name.substring(0, 50 - (extension.length + 1)) : concatenatedName;
        return "".concat(manipulatedName, ".").concat(extension);
      }
      return manipulatedName;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "cleanWhitelistChars", function (name) {
      return name.replace(_constants.WHITE_LIST_REGEX, '');
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleError", function (rawFile) {
      var files = (0, _toConsumableArray2.default)(_this.state.files);
      var currentFileIndex = files.findIndex(function (file) {
        return file.id === rawFile.id;
      });
      if (currentFileIndex !== -1) {
        rawFile.hasError = true;
        rawFile.errorMessage = "\u05D0\u05D9\u05E8\u05E2\u05D4 \u05E9\u05D2\u05D9\u05D0\u05D4, \u05D0\u05E0\u05D0 \u05E0\u05E1\u05D4 \u05E9\u05E0\u05D9\u05EA \u05D1\u05DE\u05D5\u05E2\u05D3 \u05DE\u05D0\u05D5\u05D7\u05E8 \u05D9\u05D5\u05EA\u05E8";
        files[currentFileIndex] = rawFile;
        _this.setState({
          files: files
        });
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getMaxFileId", function (filesArr) {
      if (!filesArr || (0, _lodash.isEmpty)(filesArr)) {
        return 0;
      }
      return filesArr.reduce(function (maxId, curr) {
        return curr.id && maxId < curr.id ? curr.id : maxId;
      }, 0);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getRealFilesCount", function () {
      var files = _this.state.files;
      if (!files || (0, _lodash.isEmpty)(files)) {
        return 0;
      }
      var realFiles = files.filter(function (file) {
        return !(0, _lodash.isEmpty)(file);
      });
      if (realFiles) return realFiles.length;
      return 0;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getFormError", function () {
      var error = '';
      /* eslint-disable react/prop-types */
      if (_this.props.form) {
        var fieldName = _this.props.field.name;
        var touched = (0, _formik.getIn)(_this.props.form.touched, fieldName);
        var formErrors = (0, _formik.getIn)(_this.props.form.errors, fieldName);
        error = touched && formErrors ? formErrors : '';
      }
      /* eslint-enable react/prop-types */

      return error;
    });
    var _files = _this.props.files && _this.props.files[0] ? _this.props.files.map(function (file) {
      return file && file.fileData ? file.fileData.items : {};
    }) : [];
    _this.allowedExtensions = _this.getAllowedExtensions();
    _this.currentFileErrorMessage = '';
    _this.filesCounter = _files ? _files.length : 0;
    _this.fileTypes = _this.generateUniqueKey(_this.props.fileTypes);
    _this.filesIdIncrementer = _this.getMaxFileId(_files) + 1;
    _this.uploadedFiles = _this.props.files ? _this.props.files : [];
    _this.isOnlyOneFileType = _this.props.fileTypes.length === 1;
    _this.state = {
      files: _files
    };
    _this.asyncValidator = _this.props.asyncValidator || undefined;
    (0, _printVersion.default)();
    return _this;
  }
  (0, _createClass2.default)(FileUpload, [{
    key: "render",
    value: function render() {
      var formError = this.getFormError();
      return /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_FileList.default, {
        hiddenFileType: this.props.hiddenFileType,
        title: this.props.title,
        deleteFile: this.deleteFile,
        files: this.state.files,
        types: this.fileTypes,
        allowedExtensions: this.props.allowedExtensions,
        addTagsToFile: this.addTagsToFile,
        isDisabled: this.isOnlyOneFileType,
        updateFile: this.updateFile
      }), /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("span", {
        style: {
          fontSize: '0.9rem',
          color: _grey.default[800]
        }
      }, this.props.text), /*#__PURE__*/_react.default.createElement(_DragAndDrop.default, {
        handleUpload: this.handleUpload,
        error: formError
        /* eslint-disable-next-line react/prop-types */,
        form: this.props.form
        /* eslint-disable-next-line react/prop-types */,
        field: this.props.field,
        dragFilesHereText: this.props.dragFilesHereText ? this.props.dragFilesHereText : '',
        dragFilesHereStyle: this.props.dragFilesHereStyle ? this.props.dragFilesHereStyle : {},
        chooseFilesToUploadText: this.props.chooseFilesToUploadText ? this.props.chooseFilesToUploadText : '',
        chooseFilesToUploadStyle: this.props.chooseFilesToUploadStyle ? this.props.chooseFilesToUploadStyle : {},
        multiple: this.props.maxAmountOfFiles !== 1,
        disabled: this.props.maxAmountOfFiles <= this.getRealFilesCount()
      }), formError ? /*#__PURE__*/_react.default.createElement(_core.FormHelperText, {
        role: "alert",
        id: "fileInput-error",
        error: true
      }, formError) : null);
    }
  }]);
  return FileUpload;
}(_react.Component);
FileUpload.propTypes = {
  /**
   * Error message
   */
  error: _propTypes.default.string,
  /**
   * In case your application do not use access token
   */
  dontUseAccessToken: _propTypes.default.bool,
  /**
   * The list of file types to be tagged
   */
  fileTypes: _propTypes.default.arrayOf(_FileSpecificationPropTypes.FILE_SPECIFICATION_PROP_TYPE),
  /**
   * Give a list of extensions to override the default list(mentioned under constants)
   * Excel files extensions will be blocked anyway.
   */
  allowedExtensions: _propTypes.default.arrayOf(_propTypes.default.string),
  /**
   * Max file size in MB. To override the below given default.
   */
  maxFileSize: _propTypes.default.number.isRequired,
  /**
   * Max amount of file the user will be able to upload. To override the below given default.
   */
  maxAmountOfFiles: _propTypes.default.number.isRequired,
  /**
   * A callback function will trigger the given function on every successful upload.
   * The output will be metadata about the uploaded files.
   */
  getFiles: _propTypes.default.func,
  /**
   * The backend url with the api expecting the file.
   */
  url: _propTypes.default.string.isRequired,
  /**
   * The Title that will be displayed at the top of the component(before the file types list).
   */
  title: _propTypes.default.string,
  /**
   * The Text that will be displayed above the drag and drop area.
   */
  text: _propTypes.default.string,
  /**
   * Data hrl bo attribute for automation testing.
   */
  'data-hrl-bo': _propTypes.default.string,
  /**
   * Hide file type display.
   */
  hiddenFileType: _propTypes.default.bool,
  /**
   * In order the prevent the user to re-upload the files in case of paging back and forward in your application.
   * You can save the files you got on getFiles in your app state(redux for example) and give it to this prop.
   * When you will re-enter the page the files display will render as before.
   */
  files: _propTypes.default.arrayOf(_propTypes.default.any),
  /**
   * For validation and getting to final list of uploaded file metadata use a ref to use the validate function.
   * For example in your application component give a ref --> ref={fileUploadRef}.
   * Then use the validate function as follows:  fileUploadRef.current.validate();
   * You will get an object indicating if the component is valid and the metadata as mentioned above.
   */
  dragFilesHereText: _propTypes.default.string,
  /**
   * Set drag & drop "drag here" text
   */
  dragFilesHereStyle: _propTypes.default.object,
  /**
   * Set drag & drop "drag here" style class
   */
  chooseFilesToUploadText: _propTypes.default.string,
  /**
   * Set "Choose files" text
   */
  chooseFilesToUploadStyle: _propTypes.default.object,
  /**
   * Extend file upload post request headers
   */
  customRequestHeaders: _propTypes.default.object,
  /**
   * <FileUpload asyncValidator={(files) => { return Promise<Boolean>() }} />
   */
  asyncValidator: _propTypes.default.func,
  /**
   * onError callback
   *
   *
   */
  onError: _propTypes.default.func
};
FileUpload.defaultProps = {
  maxFileSize: 7,
  maxAmountOfFiles: 5,
  title: 'רשימת מסמכים',
  getFiles: function getFiles() {},
  onError: function onError() {}
};
FileUpload.displayName = 'FileUpload';
var _default = FileUpload;
exports.default = _default;