"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _Popover = _interopRequireDefault(require("@material-ui/core/Popover"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _utils = require("../../utils");
var _core = require("@material-ui/core");
var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function Popover(props) {
  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  var pickedProps = (0, _utils.pick)(['action', 'anchorEl', 'anchorOrigin', 'anchorPosition', 'anchorReference', 'children', 'classes', 'container', 'elevation', 'getContentAnchorEl', 'marginThreshold', 'ModalClasses', 'onClose', 'onEnter', 'onEntered', 'onEntering', 'onExit', 'onExited', 'onExiting', 'open', 'PaperProps', 'transformOrigin', 'TransitionComponent', 'transitionDuration', 'TransitionProps'], props);
  return /*#__PURE__*/_react.default.createElement(_Popover.default, pickedProps);
}
Popover.propTypes = {
  /** A ref for imperative actions. It currently only supports updatePosition() action */
  action: _propTypes.default.func,
  /** This is the DOM element, or a function that returns the DOM element, that may be used to set the position of the popover */
  anchorEl: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.func]),
  /** This is the point on the anchor where the popover's anchorEl will attach to. This is not used when the anchorReference is 'anchorPosition'
   Options: vertical: [top, center, bottom]; horizontal: [left, center, right]. */
  anchorOrigin: _propTypes.default.shape({
    horizontal: _propTypes.default.oneOf(['left', 'center', 'right']),
    vertical: _propTypes.default.oneOf(['top', 'center', 'bottom'])
  }),
  /** This is the position that may be used to set the position of the popover. The coordinates are relative to the application's client area */
  anchorPosition: _propTypes.default.shape({
    left: _propTypes.default.number,
    top: _propTypes.default.number
  }),
  anchorReference: _propTypes.default.oneOf(['anchorEl', 'anchorPosition', 'none']),
  /** The content of the component*/
  children: _propTypes.default.node,
  /**    Override or extend the styles applied to the component. See CSS API below for more details */
  classes: _propTypes.default.object,
  /**    A node, component instance, or function that returns either. The container will passed to the Modal component.
   *  By default, it uses the body of the anchorEl's top-level document object, so it's simply document.body most of the time */
  container: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.func]),
  /** The elevation of the popover. */
  elevation: _propTypes.default.number,
  /** This function is called in order to retrieve the content anchor element. It's the opposite of the anchorEl prop. The content anchor element should be an element inside the popover
   * It's used to correctly scroll and set the position of the popover. The positioning strategy tries to make the content anchor element just above the anchor element */
  getContentAnchorEl: _propTypes.default.func,
  /**    Specifies how close to the edge of the window the popover can appear */
  marginThreshold: _propTypes.default.number,
  /** classes prop applied to the Modal element */
  ModalClasses: _propTypes.default.object,
  /** Callback fired when the component requests to be closed */
  onClose: _propTypes.default.func,
  /** Callback fired before the component is entering */
  onEnter: _propTypes.default.func,
  /**    Callback fired when the component has entered */
  onEntered: _propTypes.default.func,
  /**    Callback fired when the component has entering */
  onEntering: _propTypes.default.func,
  /** Callback fired before the component is exiting */
  onExit: _propTypes.default.func,
  /** Callback fired before the component is exited */
  onExited: _propTypes.default.func,
  /** Callback fired before the component is exiting */
  onExiting: _propTypes.default.func,
  /** If true, the popover is visible */
  open: _propTypes.default.bool,
  /** Props applied to the Paper element */
  PaperProps: _propTypes.default.shape({
    component: _propTypes.default.elementType
  }),
  /** This is the point on the popover which will attach to the anchor's origin.
   Options: vertical: [top, center, bottom, x(px)]; horizontal: [left, center, right, x(px)] */
  transformOrigin: _propTypes.default.shape({
    horizontal: _propTypes.default.oneOf(['left', 'center', 'right']),
    vertical: _propTypes.default.oneOf(['top', 'center', 'bottom'])
  }),
  /**    The component used for the transition */
  TransitionComponent: _propTypes.default.elementType,
  /** Set to 'auto' to automatically calculate transition time based on height */
  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.shape({
    enter: _propTypes.default.number,
    exit: _propTypes.default.number
  }), _propTypes.default.number, _propTypes.default.oneOf(['auto'])]),
  /** Props applied to the Transition element */
  TransitionProps: _propTypes.default.object
};
Popover.defaultProps = {
  anchorOrigin: {
    vertical: 'top',
    horizontal: 'left'
  },
  anchorReference: 'anchorEl',
  elevation: 8,
  marginThreshold: 16,
  PaperProps: {},
  transformOrigin: {
    vertical: 'top',
    horizontal: 'left'
  },
  TransitionComponent: _core.Grow,
  transitionDuration: 'auto',
  TransitionProps: {}
};
var _default = Popover;
exports.default = _default;