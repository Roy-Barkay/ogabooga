"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _Tooltip = _interopRequireDefault(require("@material-ui/core/Tooltip"));

var _utils = require("../../utils");

var _styles = require("@material-ui/core/styles");

var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function arrowGenerator() {
  return {
    '& .MuiTooltip-arrow': {
      '&::before': {
        backgroundColor: 'white',
        border: '1px solid #5fa3d5'
      }
    }
  };
}

function Tooltip(props) {
  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  var bootstrapStyles = (0, _styles.makeStyles)(function (theme) {
    return {
      popperArrow: arrowGenerator(),
      tooltip: _objectSpread({
        backgroundColor: 'white',
        border: '1px solid #5fa3d5',
        borderRadius: '4px',
        padding: '4px 8px 5px 8px',
        boxShadow: '0 1px 6px rgba(0, 0, 0, 0.2)',
        color: '#000',
        fontSize: '12px',
        maxWidth: props.maxWidth
      }, props.styleTootlip)
    };
  });
  var classes = bootstrapStyles();
  var pickedProps = (0, _utils.pick)(['children', 'disableFocusListener', 'disableHoverListener', 'disableTouchListener', 'id', 'onClose', 'onOpen', 'open', 'placement', 'title', 'interactive', 'arrow', 'leaveTouchDelay', 'data-hrl-bo', 'PopperProps'], props);

  var checkAttribute = function checkAttribute(attr, defaultValue) {
    if (attr !== undefined) {
      if (typeof attr === 'string') {
        if (attr.trim() !== '') {
          return attr;
        } else {
          return null;
        }
      } else {
        return attr;
      }
    } else {
      return defaultValue;
    }
  };

  var tooltipRole = checkAttribute(props.role, 'tooltip');
  var ariaLabel = checkAttribute(props.ariaLabel, "".concat(pickedProps.title));
  var ariaDescribedBy = checkAttribute(props.ariaDescribedBy, null);
  var tabIndex = (props === null || props === void 0 ? void 0 : props.tabIndex) === false ? null : 0;
  return /*#__PURE__*/_react.default.createElement(_Tooltip.default, (0, _extends2.default)({
    enterTouchDelay: 0,
    classes: classes
  }, pickedProps, {
    className: "Mui-Tooltip-content",
    role: tooltipRole,
    tabIndex: tabIndex,
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedBy,
    "data-hrl-bo": props.bo
  }));
}

Tooltip.propTypes = {
  /**
   * Tooltip reference element. Needs to be able to hold a ref
   */
  children: _propTypes.default.node,

  /**
   * Do not respond to focus events
   */
  disableFocusListener: _propTypes.default.bool,

  /**
   * Do not respond to hover events
   */
  disableHoverListener: _propTypes.default.bool,

  /**
   * Do not respond to hover events
   */
  disableTouchListener: _propTypes.default.bool,

  /**
   * The relationship between the tooltip and the wrapper component is not clear from the DOM. This prop is used with aria-describedby to solve the accessibility issue. If you don't provide this prop. It falls back to a randomly generated id
   */
  id: _propTypes.default.string,

  /**
   * Callback fired when the tooltip requests to be closed
   */
  onClose: _propTypes.default.func,

  /**
   * Callback fired when the tooltip requests to be open
   */
  onOpen: _propTypes.default.func,

  /**
   * If true, the tooltip is shown
   */
  open: _propTypes.default.bool,

  /**
   * Tooltip placement
   */
  placement: _propTypes.default.oneOf(['bottom-start', 'bottom', 'bottom-end', 'right-start', 'right', 'right-end', 'top-start', 'top', 'top-end', 'left-start', 'left', 'left-end']),

  /**
   *  Tooltip title. Zero-length titles string are never displayed
   */
  title: _propTypes.default.node,

  /**
   * If true, adds an arrow to the tooltip.
   */
  arrow: _propTypes.default.bool,

  /**
   * Set the tooltip's window max width
   */
  maxWidth: _propTypes.default.number,

  /**
   * Set custom style tooltip
   */
  styleTootlip: _propTypes.default.object,

  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   */
  leaveTouchDelay: _propTypes.default.number,

  /**
   * Add accessibility role, default = 'tooltip' . if role==="" then it will not be added to DOM'.
   */
  role: _propTypes.default.string,

  /**
   * Add accessibility ariaLabel, default = props.title. if ariaLabel==="" then it will not be added to DOM'.
   */
  ariaLabel: _propTypes.default.string,

  /**
   * default = 0.
   */
  tabIndex: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.bool]),

  /**
   * Add accessibility ariaDescribedBy, if ariaDescribedBy==="" then it will not be added to DOM'.
   */
  ariaDescribedBy: _propTypes.default.string,

  /**
   * this properties will be used for QA teams and not to use by developers
   */
  bo: _propTypes.default.string,

  /** this properties will be used for manage properties of POPPER    */
  PopperProps: _propTypes.default.object
};
Tooltip.defaultProps = {
  disableFocusListener: false,
  disableHoverListener: false,
  disableTouchListener: false,
  placement: 'bottom',
  arrow: true,
  maxWidth: 300,
  leaveTouchDelay: 50000,
  tabIndex: 0,
  bo: "bo-tooltip-".concat(Math.random().toString(36).slice(-6)),
  PopperProps: null
};
var _default = Tooltip;
exports.default = _default;