"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = _interopRequireWildcard(require("react"));

var _pickers = require("@material-ui/pickers");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _moment = _interopRequireDefault(require("moment"));

var _formik = require("formik");

var _Event = _interopRequireDefault(require("@material-ui/icons/Event"));

var _core = require("@material-ui/core");

var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var defaultDateFormat = 'DD/MM/YYYY';

var getInitialValue = function getInitialValue(props) {
  if (!props) {
    return null;
  }

  var value = props.form ? props.field.value : props.value;

  if ((0, _typeof2.default)(value) === 'object') {
    return value ? (0, _moment.default)(value) : null;
  } else if (typeof value === 'string') {
    return value ? (0, _moment.default)(value, props.format || defaultDateFormat) : null;
  }
};

var DatePickerCommon = function DatePickerCommon(props) {
  var _useState = (0, _react.useState)(false),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      forceRender = _useState2[0],
      updateForceRender = _useState2[1];

  var value = (0, _react.useRef)(getInitialValue(props));
  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  var hasError = !!props.error;
  var fieldHelperText = props.helperText;
  var hrlBo = props['data-hrl-bo'] ? props['data-hrl-bo'] : 'datepicker';
  /* eslint-disable react/prop-types */

  if (props.form) {
    var fieldName = props.field.name;
    var touched = (0, _formik.getIn)(props.form.touched, fieldName);
    var fieldError = (0, _formik.getIn)(props.form.errors, fieldName);
    /* eslint-enable react/prop-types */

    hasError = touched && fieldError;
    fieldHelperText = touched && fieldError ? fieldError : props.helperText;
  }

  var handleChange = function handleChange(momentObj, date) {
    var e = {};
    /* eslint-disable react/prop-types */

    if (props.form) {
      e.target = {
        name: props.field.name,
        value: momentObj
      };
      props.field.onChange(e);
    }
    /* eslint-enable react/prop-types */


    if (props.onChange) props.onChange(momentObj, date);
    value.current = momentObj;
  };

  var handleBlur = function handleBlur(date) {
    var e = {};
    /* eslint-disable react/prop-types */

    if (props.form) {
      e.target = {
        name: props.field.name,
        value: date
      };
      props.field.onBlur(e);
    }
    /* eslint-enable react/prop-types */


    if (props.onBlur) props.onBlur(date);
  };

  var handleClose = function handleClose() {
    if (props.isBlurOnClose) {
      handleBlur(value.current);
    }

    if (props.onClose) props.onClose();
  };

  var extraProps = {
    inputProps: {
      'aria-required': props.required,
      'data-hrl-bo': "".concat(hrlBo, "-input"),
      'aria-invalid': hasError,
      'aria-label': props.ariaLabel,
      style: {
        direction: 'ltr',
        textAlign: 'right'
      }
    }
  };
  var dialogProps = {
    'role': null,
    PaperProps: {
      'data-hrl-bo': "".concat(hrlBo, "-dialog"),
      'aria-label': 'בחר תאריך'
    }
  };
  (0, _react.useEffect)(function () {
    value.current = getInitialValue(props);
    updateForceRender(!forceRender);
  }, [props.value]);

  var commonProps = _objectSpread(_objectSpread(_objectSpread({}, props), extraProps), {}, {
    value: value.current,
    error: hasError,
    helperText: fieldHelperText,
    onChange: handleChange,
    onClose: handleClose,
    KeyboardButtonProps: {
      'aria-label': 'פתיחה של תאריכון',
      'data-hrl-bo': "".concat(hrlBo, "-button-calendar")
    },
    leftArrowButtonProps: {
      'data-hrl-bo': "".concat(hrlBo, "-arrow-back"),
      'aria-label': 'חודש קודם'
    },
    rightArrowButtonProps: {
      'data-hrl-bo': "".concat(hrlBo, "-arrow-forward"),
      'aria-label': 'חודש הבא'
    },
    InputLabelProps: props.InputLabelProps || Object.assign({}, props.required && props.hideRequiredAsterisk && {
      required: false
    }),
    DialogProps: dialogProps,
    format: props.format || defaultDateFormat,
    cancelLabel: 'בטל',
    okLabel: 'בחר',
    clearLabel: 'נקה'
  });

  return props.allowManualInput ? /*#__PURE__*/_react.default.createElement(_pickers.KeyboardDatePicker, (0, _extends2.default)({
    InputProps: {
      onBlur: function onBlur() {
        handleBlur(value.current);
      }
    }
  }, commonProps)) : /*#__PURE__*/_react.default.createElement(_pickers.DatePicker, (0, _extends2.default)({
    InputProps: {
      endAdornment: /*#__PURE__*/_react.default.createElement(_core.InputAdornment, {
        position: "end"
      }, /*#__PURE__*/_react.default.createElement(_core.IconButton, null, /*#__PURE__*/_react.default.createElement(_Event.default, null))),
      onBlur: function onBlur() {
        handleBlur(value.current);
      }
    }
  }, commonProps));
};

DatePickerCommon.propTypes = {
  /** On change event handler. if allowManualInput = true  (date: DateIOType, value?: string | null) => void, if false (date: DateIOType) => void */
  onChange: _propTypes.default.func,

  /** On close event handler */
  onClose: _propTypes.default.func,

  /** Picker container option */
  variant: _propTypes.default.oneOf(['dialog', 'inline', 'static']),

  /** Array of views to show */
  views: _propTypes.default.arrayOf(['year', 'month', 'date']),

  /** Force rendering in particular orientation */
  orientation: _propTypes.default.oneOf(['portrait', 'landscape']),

  /** Max selectable date */
  maxDate: _propTypes.default.objectOf(Date),

  /** Min selectable date */
  minDate: _propTypes.default.objectOf(Date),

  /** Disable past dates */
  disablePast: _propTypes.default.bool,

  /** Disable future dates */
  disableFuture: _propTypes.default.bool,

  /** Disable datepicker text field */
  disabled: _propTypes.default.bool,

  /** Close popup on ok button click */
  autoOk: _propTypes.default.bool,

  /** The id of the input element. Use this prop to make label and helperText accessible for screen readers. */
  id: _propTypes.default.string.isRequired,

  /**    The label content. */
  label: _propTypes.default.node,

  /** Default value */
  value: _propTypes.default.oneOfType([_propTypes.default.objectOf(_moment.default), _propTypes.default.string]),

  /** Enables keyboard listener for moving between days in calendar  */
  allowKeyboardControl: _propTypes.default.bool,

  /** Date format */
  format: _propTypes.default.string,

  /** Cancel button label text */
  cancelLabel: _propTypes.default.string,

  /** Ok button label text */
  okLabel: _propTypes.default.string,

  /** Clear button label text */
  clearLabel: _propTypes.default.string,

  /** Clear button label text */
  allowManualInput: _propTypes.default.bool,

  /** aria label text and format */
  ariaLabel: _propTypes.default.string,

  /** is run onBlur event handler when OnClose is fired  */
  isBlurOnClose: _propTypes.default.bool,

  /** Set error state  */
  error: _propTypes.default.bool,

  /** The helper text content. */
  helperText: _propTypes.default.node,

  /** If true, the input element will be required. */
  required: _propTypes.default.bool,

  /** Function to be called when input was blur. */
  onBlur: _propTypes.default.func,

  /** Data hrl bo attribute for automation testing. */
  'data-hrl-bo': _propTypes.default.string,

  /** Props applied to the InputLabel element. */
  InputLabelProps: _propTypes.default.object,

  /** If true, the label will not display the asterisk.  */
  hideRequiredAsterisk: _propTypes.default.bool
};
DatePickerCommon.defaultProps = {
  variant: 'dialog',
  orientation: 'portrait',
  disableFuture: false,
  disablePast: false,
  disabled: false,
  autoOk: true,
  allowKeyboardControl: true,
  format: defaultDateFormat,
  cancelLabel: 'בטל',
  okLabel: 'בחר',
  clearLabel: 'נקה',
  allowManualInput: true,
  ariaLabel: '',
  isBlurOnClose: true,
  hideRequiredAsterisk: false
};
var _default = DatePickerCommon;
exports.default = _default;