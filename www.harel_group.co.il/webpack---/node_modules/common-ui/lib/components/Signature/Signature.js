"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _ = require("../..");

var _formik = require("formik");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _commonIcons = require("common-icons");

var _Signature = _interopRequireDefault(require("./Signature.style"));

var _reactSignatureCanvas = _interopRequireDefault(require("react-signature-canvas"));

var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));

var _core = require("@material-ui/core");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Signature(props) {
  var classes = (0, _Signature.default)(props);
  var signatureRef = (0, _react.useRef)(props.value);
  var canvasRef = (0, _react.useRef)(null);
  var signaturePadRef = {};
  var fieldError = props.error;
  var fieldHelperText = props.helperText;

  if (props.form) {
    var fieldName = props.field.name;
    var touched = (0, _formik.getIn)(props.form.touched, fieldName);
    var formErrors = (0, _formik.getIn)(props.form.errors, fieldName);
    fieldError = !!(touched && formErrors);
    fieldHelperText = fieldError ? formErrors : props.helperText;
  }

  var signaturePadProps = {
    velocityFilterWeight: props.velocityFilterWeight,
    minWidth: props.minWidth,
    maxWidth: props.maxWidth,
    minDistance: props.minDistance,
    dotSize: props.dotSize,
    penColor: props.penColor,
    throttle: props.throttle,
    canvasProps: Object.assign({
      className: classes.sigPad,
      tabIndex: 0,
      'aria-describedby': 'errSign',
      'aria-invalid': fieldError,
      'aria-label': props.ariaLabel
    }, props.width && {
      width: props.width
    }, props.height && {
      height: props.height
    })
  };

  var onCanvasVisibleChange = function onCanvasVisibleChange(entries) {
    var _entries = (0, _slicedToArray2.default)(entries, 1),
        entry = _entries[0];

    var ratio = entry.intersectionRatio;

    if (ratio > 0 && signaturePadRef && signatureRef.current) {
      signaturePadRef.fromDataURL(signatureRef.current, {
        ratio: 1
      });
    }
  };

  var handlerChange = function handlerChange() {
    var signature = signaturePadRef.toDataURL('data:image/png;base64,signature');
    signatureRef.current = signature;

    if (props.onChange) {
      props.onChange(signature);
    }

    if (props.form) {
      props.form.setFieldValue(props.field.name, signature);
      props.form.setFieldTouched(props.field.name);
    }
  };

  var clear = function clear() {
    signaturePadRef.clear();
    signatureRef.current = null;

    if (props.onClear) {
      props.onClear();
    }

    if (props.form) {
      props.form.setFieldValue(props.field.name, null);
    }
  };

  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  (0, _react.useEffect)(function () {
    if (signaturePadRef && props.hasOwnProperty('value')) {
      if (props !== null && props !== void 0 && props.value) {
        if (signatureRef.current !== props.value) {
          signatureRef.current = props.value;
          signaturePadRef.fromDataURL(props.value, {
            ratio: 1
          });
        }
      } else {
        if (signatureRef.current !== null) {
          clear();
        }
      }
    }
  }, [props.value, signaturePadRef]);
  (0, _react.useEffect)(function () {
    var hasIntersectionObserver = 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype;

    if (hasIntersectionObserver) {
      var observer = new IntersectionObserver(onCanvasVisibleChange, {
        threshold: [0, 1]
      });

      if (canvasRef.current) {
        observer.observe(canvasRef.current);
      }

      return function () {
        if (canvasRef.current) {
          observer.unobserve(canvasRef.current);
        }
      };
    }
  }, [canvasRef]);
  return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_core.FormControl, {
    className: classes.sigContainer,
    id: props.id,
    error: !!fieldError,
    "data-hrl-bo": "".concat(props['data-hrl-bo'], "-canvas")
  }, props.label && /*#__PURE__*/_react.default.createElement(_core.FormLabel, {
    required: props.required
  }, props.label, ' '), /*#__PURE__*/_react.default.createElement(_reactSignatureCanvas.default, (0, _extends2.default)({
    onEnd: function onEnd() {
      return handlerChange();
    },
    ref: function ref(_ref) {
      if (_ref) {
        canvasRef.current = _ref._canvas;
        signaturePadRef = _ref;
        (props === null || props === void 0 ? void 0 : props.value) && signaturePadRef.fromDataURL(props.value, {
          ratio: 1
        });
      }
    },
    clearOnResize: false
  }, signaturePadProps)), fieldHelperText && !fieldError && /*#__PURE__*/_react.default.createElement(_core.FormHelperText, null, fieldHelperText), fieldError && /*#__PURE__*/_react.default.createElement(_core.FormHelperText, {
    error: true,
    id: 'errSign'
  }, fieldHelperText)), /*#__PURE__*/_react.default.createElement("div", {
    className: classes.sigButtonContainer
  }, /*#__PURE__*/_react.default.createElement(_.Button, (0, _extends2.default)({
    size: "small",
    variant: props.variantButton || 'contained',
    onClick: clear,
    "aria-label": "\u05E0\u05E7\u05D4 \u05D7\u05EA\u05D9\u05DE\u05D4",
    "data-hrl-bo": "".concat(props['data-hrl-bo'], "-clear"),
    className: classes.sigButton,
    icon: props.iconButton,
    iconPlacement: props.iconPlacement
  }, props.buttonProps), props.buttonText)));
}

Signature.propTypes = {
  /** [SignaturePad] velocityFilterWeight : number, default: 0.7 */
  velocityFilterWeight: _propTypes.default.number,

  /** [SignaturePad] minWidth : number, default: 0.5 */
  minWidth: _propTypes.default.number,

  /** [SignaturePad] maxWidth : number, default: 2.5 */
  maxWidth: _propTypes.default.number,

  /** [SignaturePad] minDistance: number, default: 5 */
  minDistance: _propTypes.default.number,

  /** [SignaturePad] dotSize : number or function, default: () => (this.minWidth + this.maxWidth) / 2 */
  dotSize: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.number]),

  /** [SignaturePad] penColor : string, default: 'black' */
  penColor: _propTypes.default.string,

  /** [SignaturePad] throttle: number, default: 16 */
  throttle: _propTypes.default.number,

  /**
   * Function to be called when canvas is changed
   */
  onChange: _propTypes.default.func,

  /**
   * Function to be called when signature is clear
   */
  onClear: _propTypes.default.func,

  /**
   * Button text
   */
  buttonText: _propTypes.default.string,

  /**
   *  Button icon, component
   */
  iconButton: _propTypes.default.node,

  /**
   * Material UI Button
   * variant?: 'text' | 'outlined' | 'contained';
   */
  variantButton: _propTypes.default.string,

  /**
   * Button icon placement
   */
  iconPlacement: _propTypes.default.oneOf(['start', 'end']),

  /**
   * Override data-hrl-bo
   */
  'data-hrl-bo': _propTypes.default.string,

  /**
   * TODO: Not in use
   * minHeight : number
   */
  minHeight: _propTypes.default.number,

  /**
   * TODO: Not in use
   * maxHeight : number
   */
  maxHeight: _propTypes.default.number,

  /**
   * Override button props
   */
  buttonProps: _propTypes.default.any,

  /**
   * Canvas height
   */
  height: _propTypes.default.any,

  /**
   * Canvas width
   */
  width: _propTypes.default.any,

  /**
   * canvas label
   */
  ariaLabel: _propTypes.default.string,
  value: _propTypes.default.any,
  error: _propTypes.default.bool,
  helperText: _propTypes.default.node,
  label: _propTypes.default.node,
  id: _propTypes.default.string,
  required: _propTypes.default.bool,

  /**
   * Formik instance
   */
  form: _propTypes.default.any,
  field: _propTypes.default.any
};
Signature.defaultProps = {
  velocityFilterWeight: 0.7,
  minWidth: 0.5,
  maxWidth: 2.5,
  minDistance: 5,
  dotSize: 2,
  penColor: 'black',
  throttle: 16,
  buttonText: 'נקה',
  iconButton: /*#__PURE__*/_react.default.createElement(_commonIcons.IconTrash, null),
  variantButton: 'contained',
  iconPlacement: 'end',
  'data-hrl-bo': 'signature',
  buttonProps: {},
  ariaLabel: 'נא לחתום באמצעות העכבר'
};
var _default = Signature;
exports.default = _default;