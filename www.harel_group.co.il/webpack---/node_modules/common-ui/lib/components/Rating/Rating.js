"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _Rating = _interopRequireDefault(require("@material-ui/lab/Rating"));

var _utils = require("../../utils");

var _Star = _interopRequireDefault(require("@material-ui/icons/Star"));

var _Rating2 = _interopRequireDefault(require("./Rating.style"));

var _Label = _interopRequireDefault(require("./Label"));

var _core = require("@material-ui/core");

var _formik = require("formik");

var _printVersion = _interopRequireDefault(require("../../utils/printVersion"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Rating(props) {
  (0, _react.useEffect)(function () {
    return (0, _printVersion.default)();
  }, []);
  var classes = (0, _Rating2.default)(props);
  var pickedProps = (0, _utils.pick)(['name', 'readOnly', 'classes', 'disabled', 'value', 'max', 'onChange', 'onChangeActive', 'emptyIcon', 'getLabelText', 'icon', 'id', 'enableRatingText', 'IconContainerComponent', 'precision', 'size', 'helperText', 'error'], props);
  var hrlBo = props['data-hrl-bo'] ? props['data-hrl-bo'] : 'rating';
  var fieldError = props.error;
  var fieldHelperText = props.helperText;
  /* eslint-disable react/prop-types */

  if (props.form) {
    var fieldName = props.field.name;
    var touched = (0, _formik.getIn)(props.form.touched, fieldName);
    var formErrors = (0, _formik.getIn)(props.form.errors, fieldName);
    /* eslint-enable react/prop-types */

    fieldError = touched && formErrors ? true : false;
    fieldHelperText = fieldError ? formErrors : props.helperText;
  }

  var handlerChange = function handlerChange(e) {
    if (props.onChange) props.onChange(e, e.target.value);
    /* eslint-disable react/prop-types */

    if (props.form) {
      var clonedEvent = Object.assign({}, e);
      clonedEvent.target.name = props.field.name;
      props.field.onChange(clonedEvent);
    }
    /* eslint-enable react/prop-types */

  };

  var handleBlur = function handleBlur(e) {
    if (props.onChangeActive) props.onChangeActive(e);
    /* eslint-disable react/prop-types */

    if (props.form) {
      var clonedEvent = Object.assign({}, e);
      clonedEvent.target.name = props.field.name;
      props.field.onBlur(clonedEvent);
    }
    /* eslint-enable react/prop-types */

  };

  delete pickedProps.helperText;
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_Label.default, {
    required: props.required,
    id: props.id,
    "data-hrl-bo": "".concat(hrlBo, "-label")
  }, props.label), /*#__PURE__*/_react.default.createElement("div", {
    className: classes.ratinWrapper
  }, pickedProps.enableRatingText && /*#__PURE__*/_react.default.createElement(_core.Typography, {
    variant: "caption"
  }, "\u05DC\u05D0 \u05D8\u05D5\u05D1 \u05D1\u05DB\u05DC\u05DC"), /*#__PURE__*/_react.default.createElement(_Rating.default, (0, _extends2.default)({}, pickedProps, {
    "aria-labelledby": props.id,
    onChange: handlerChange,
    onChangeActive: handleBlur,
    "data-hrl-bo": "".concat(hrlBo, "-icons"),
    getLabelText: function getLabelText(value) {
      return "".concat(value, " \u05DB\u05D5\u05DB\u05D1\u05D9\u05DD");
    }
  })), pickedProps.enableRatingText && /*#__PURE__*/_react.default.createElement(_core.Typography, {
    variant: "caption"
  }, "\u05D8\u05D5\u05D1 \u05DE\u05D0\u05D5\u05D3")), fieldHelperText && !fieldError ? /*#__PURE__*/_react.default.createElement(_core.FormHelperText, {
    "data-hrl-bo": "".concat(hrlBo, "-helper-text")
  }, fieldHelperText) : null, fieldError ? /*#__PURE__*/_react.default.createElement(_core.FormHelperText, {
    error: true,
    "data-hrl-bo": "".concat(hrlBo, "-error")
  }, fieldHelperText) : null);
}

Rating.displayName = 'Rating';
Rating.propTypes = {
  /** The id of the input element. */
  id: _propTypes.default.string,

  /**
   *    Override or extend the styles applied to the component.
   */
  classes: _propTypes.default.object,

  /**
   * The value of the rating bar
   */
  value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),

  /**
   * The max value of the rating bar
   */
  max: _propTypes.default.number,

  /**
   * The name attribute of the radio input elements. If readOnly is false, the prop is required, this input name`should be unique within the parent form.
   */
  name: _propTypes.default.string,

  /**
   * Callback fired when the value changes
   */
  onChange: _propTypes.default.func,

  /**
   * Callback function that is fired when the hover state changes
   */
  onChangeActive: _propTypes.default.func,

  /**
   * Don't allow input if set to true
   */
  readOnly: _propTypes.default.bool,

  /**
   * Disables the rating and gray it out if set to true
   */
  disabled: _propTypes.default.bool,

  /**
   * The icon to display when empty
   */
  emptyIcon: _propTypes.default.node,

  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current value of the rating.
   */
  getLabelText: _propTypes.default.func,

  /**
   * The icon to display.
   */
  icon: _propTypes.default.node,

  /**
   * The component containing the icon.
   */
  IconContainerComponent: _propTypes.default.elementType,

  /**
   * The minimum increment value change allowed.
   */
  precision: _propTypes.default.number,

  /**
   * The size of the rating.
   */
  size: _propTypes.default.oneOf(['small', 'medium', 'large']),

  /**
   * required: If rating required
   */
  required: _propTypes.default.bool,

  /** Error message if value is not valid */
  error: _propTypes.default.string,

  /**
   * Helper text to appear under the input
   */
  helperText: _propTypes.default.node,

  /**
   *
   */
  enableRatingText: _propTypes.default.bool,

  /** The label content. */
  label: _propTypes.default.node,

  /** Data hrl bo attribute for automation testing. */
  'data-hrl-bo': _propTypes.default.string
};
Rating.defaultProps = {
  readOnly: false,
  size: 'medium',
  enableRatingText: false,
  value: null,
  precision: 1,
  max: 5,
  icon: /*#__PURE__*/_react.default.createElement(_Star.default, {
    fontSize: "inherit"
  }),
  disabled: false,
  required: false,
  error: null,
  helperText: ''
};
var _default = Rating;
exports.default = _default;