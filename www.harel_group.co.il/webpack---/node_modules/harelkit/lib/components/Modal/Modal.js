"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _Portal = _interopRequireDefault(require("../Portal"));

var _Backdrop = _interopRequireDefault(require("./Backdrop"));

var _Head = _interopRequireDefault(require("./Head"));

var _Body = _interopRequireDefault(require("./Body"));

var _Footer = _interopRequireDefault(require("./Footer"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _Modal = _interopRequireDefault(require("./Modal.style"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var noop = function noop() {}; // TODO: restore focus
// https://dev.to/viclafouch/build-a-complete-modal-component-with-react-hooks-2fk8


var Modal = function Modal(props) {
  var sentinelStart = (0, _react.useRef)(null);
  var sentinelEnd = (0, _react.useRef)(null);
  var id = props.id,
      children = props.children,
      disableBackdropClick = props.disableBackdropClick,
      disableEscapeKeyDown = props.disableEscapeKeyDown,
      disableCloseButton = props.disableCloseButton,
      onBackdropClick = props.onBackdropClick,
      onClose = props.onClose,
      onEscapeKeyDown = props.onEscapeKeyDown,
      open = props.open,
      icon = props.icon,
      title = props.title,
      bo = props.bo;
  var labelledby = "".concat(id, "-title");
  var describedby = "".concat(id, "-description");

  var _useState = (0, _react.useState)(open),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var handleEscape = (0, _react.useCallback)(function (event) {
    if (event.keyCode === 27) {
      // escape
      onEscapeKeyDown(event);
      onClose(event, 'escapeKeyDown');
    }
  }, [onEscapeKeyDown, onClose]); // add close on backdrop click support

  var handleBackdropClick = function handleBackdropClick(event) {
    if (event.target !== event.currentTarget) {
      return;
    }

    onBackdropClick(event);

    if (!disableBackdropClick && onClose) {
      onClose(event, 'backdropClick');
    }
  };

  var loopFocus = (0, _react.useCallback)(function (event) {
    if (event.keyCode === 9) {
      // tab
      if (event.shiftKey) {
        if (event.target === sentinelStart.current) {
          sentinelEnd.current.focus();
        }
      } else {
        if (event.target === sentinelEnd.current) {
          sentinelStart.current.focus();
        }
      }
    }
  }, []);

  var ariaHidden = function ariaHidden(node, show) {
    if (show) {
      node.setAttribute('aria-hidden', 'true');
    } else {
      node.removeAttribute('aria-hidden');
    }
  }; // focus on first element on open


  (0, _react.useEffect)(function () {
    /**
     * handle container siblings aria-hidden  
     *
     * @param   {element} container       container element
     * @param   {element} currentNode     current node to exclude
     * @param   {array}   nodesToExclude  nodes to exclude
     * @param   {bool}    show            show or hide
     */
    var ariaHiddenSiblings = function ariaHiddenSiblings(container, currentNode) {
      var nodesToExclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var show = arguments.length > 3 ? arguments[3] : undefined;
      var blacklist = [currentNode].concat(_toConsumableArray(nodesToExclude));
      var blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
      [].forEach.call(container.children, function (node) {
        if (node.nodeType === 1 && blacklist.indexOf(node) === -1 && blacklistTagNames.indexOf(node.tagName) === -1) {
          ariaHidden(node, show);
        }
      });
    };

    if (isOpen) {
      sentinelStart.current.focus(); // disable scroll

      document.body.style.overflow = 'hidden'; // add aria-hidden to body siblings

      ariaHiddenSiblings(document.body, document.getElementById(id), [], true);
    } else {
      // enable back scroll
      document.body.style.overflow = null; // remove aria-hidden from body siblings

      ariaHiddenSiblings(document.body, document.getElementById(id), [], false);
    }
  }, [isOpen, id]); // add close on escape support

  (0, _react.useEffect)(function () {
    if (!disableEscapeKeyDown && isOpen) {
      document.addEventListener('keydown', handleEscape, false);
    }

    return function () {
      if (!disableEscapeKeyDown) {
        document.removeEventListener('keydown', handleEscape, false);
      }
    };
  }, [handleEscape, disableEscapeKeyDown, isOpen]); // add focus trap support

  (0, _react.useEffect)(function () {
    document.addEventListener('keydown', loopFocus, false);
    return function () {
      document.removeEventListener('keydown', loopFocus, false);
    };
  }, [loopFocus]); // handle open on init

  (0, _react.useEffect)(function () {
    if (open) {
      setIsOpen(true);
    } else {
      setIsOpen(false);
    }
  }, [open]);
  return isOpen ? /*#__PURE__*/_react.default.createElement(_Portal.default, {
    id: id
  }, /*#__PURE__*/_react.default.createElement(_Modal.default.Root, {
    role: "presentation"
  }, /*#__PURE__*/_react.default.createElement(_Backdrop.default, {
    onClick: handleBackdropClick
  }), /*#__PURE__*/_react.default.createElement(_Modal.default.Sentinel, {
    tabIndex: 0,
    ref: sentinelStart
  }), /*#__PURE__*/_react.default.createElement(_Modal.default.Modal, {
    tabIndex: "-1",
    role: "dialog",
    "aria-labelledby": labelledby,
    "aria-describedby": describedby,
    "aria-hidden": "false"
  }, /*#__PURE__*/_react.default.createElement(_Head.default, {
    disableCloseButton: disableCloseButton,
    icon: icon,
    onClose: onClose,
    bo: bo
  }), title && /*#__PURE__*/_react.default.createElement(_Modal.default.ModalTitle, {
    "aria-level": "1",
    role: "heading",
    "data-hrl-bo": bo ? "".concat(bo, "-modal-title") : null,
    id: labelledby
  }, title), /*#__PURE__*/_react.default.createElement(_Modal.default.Content, null, /*#__PURE__*/_react.default.createElement("div", {
    id: describedby
  }, children))), /*#__PURE__*/_react.default.createElement(_Modal.default.Sentinel, {
    tabIndex: 0,
    ref: sentinelEnd
  }))) : null;
};

Modal.Footer = _Footer.default;
Modal.Body = _Body.default;
Modal.propTypes = {
  /**
   * Modal id
   */
  id: _propTypes.default.string,

  /**
   * If true, clicking the backdrop will not fire onClose
   */
  disableBackdropClick: _propTypes.default.bool,

  /**
   * If true, hitting escape will not fire onClose
   */
  disableEscapeKeyDown: _propTypes.default.bool,

  /**
   * Modal head icon
   */
  icon: _propTypes.default.element,

  /**
   * If true the modla is open
   */
  open: _propTypes.default.bool,

  /**
   * If true, the modal will not show the close button (x)
   */
  disableCloseButton: _propTypes.default.bool,

  /**
   * Callback fired when the backdrop is pressed,
   */
  onBackdropClick: _propTypes.default.func,

  /**
   * Callback fired when the component requests to be closed. 
   * The reason parameter can optionally be used to control the response to onClose.
   * <strong>Signature:</strong>
   * function(event: object, reason: string) => void
   * event: The event source of the callback.
   * reason: Can be: "escapeKeyDown", "backdropClick", "closeButtonClick"
   */
  onClose: _propTypes.default.func,

  /**
   * Callback fired when the escape key is pressed
   */
  onEscapeKeyDown: _propTypes.default.func,

  /**
   * Modal title
   */
  title: _propTypes.default.string,

  /**
   * Will add data-hrl-bo attribute to modal.
   * 
   * bo attribute:
   * ${bo}-modal-x
   * ${bo}-modal-title
   * ${bo}-modal-body
   * ${bo}-modal-footer
   */
  bo: _propTypes.default.string
};
Modal.defaultProps = {
  id: 'modal',
  open: false,
  disableCloseButton: false,
  onBackdropClick: noop,
  onEscapeKeyDown: noop
};
var _default = Modal;
exports.default = _default;